# ФУНКЦИИ И РЕКУУРСИЯ. МЕТОД БЫСТРОЙ СОРТИРОВКИ И МЕТОД СЛИЯНИЯ.
# Необходимо создать функцию sumNumbers(n), которая будет считать
# сумму всех элементов от 1 до n.

# def sumNumbers(n):

#     summa = 0
#     for i in range(1, n + 1):
#         summa += i
#         return summa

#     n = int(input())  # 5
#     print(sumNumbers(n))  # 15


# # . function_file.py (Новый Python файл, в котором находятся функция f(x))


# def f(x):
#     if x == 1:
#         return 'Целое'
#     elif x == 2.3:
#         return 23
#     return # выход из функции

# # С помощью import мы можем вызвать эту функцию в другом скрипте и дальше
# # использовать её в новом файле. Можно сократить название функции в рабочем
# # файле с помощью команды:

# import function_file

# print(function_file.f(1)) # Целое
# print(function_file.f(2.3)) # 23
# print(function_file.f(28)) # None

# # В Python можно перемножать строку на число.
# # В данной функции есть два аргумента: symbol (символ или число) и count (число, на
# # которое умножается первый аргумент).
# # Если введены оба аргумента, функция работает без ошибок. Если только символ —
# # функция выдает ошибку.

# def new_string(symbol, count):
#     return symbol * count

# print(new_string('!', 5)) # !!!!!
# print(new_string('!')) # TypeError missing 1 required ...

# # Можно указать значение переменной count по умолчанию. Например, если
# # значение явно не указано (нет второго аргумента), по умолчанию значение
# # переменной count равно трем.

# def new_string(symbol, count=3):
#     return symbol * count

# print(new_string('!', 5)) # !!!!!
# print(new_string('!')) # !!!
# print(new_string(4)) # 12

# # Возможность передачи неограниченного количества аргументов
# # ● Можно указать любое количество значений аргумента функции.
# # ● Перед аргументом надо поставить *.

# def concatenatio(*params):
#     res = ""
#     for item in params:
#         res += item
#     return res
# print(concatenatio('a', 's', 'd', 'w')) # asdw
# print(concatenatio('a', '1')) # a1
# # print(concatenatio(1, 2, 3, 4)) # TypeError: ...


# # Рекурсия
# #  Рекурсия — это функция, вызывающая сама себя.

# # При описании рекурсии важно указать, когда функции надо
# # остановиться и перестать вызывать саму себя. По-другому говоря, необходимо
# # указать базис рекурсии

# # : Пользователь вводит число n. Необходимо вывести n - первых
# # членов последовательности Фибоначчи.
# # Напоминание: Последовательно Фибоначчи, это такая последовательность, в
# # которой каждое последующее число равно сумму 2-ух предыдущих

# def fib(n):
#     if n in [1, 2]:
#         return 1
#     return fib(n - 1) + fib(n - 2)

# list_1 = []
# for i in range(1, 10):
# list_1.append(fib(i - 2))
# print(list_1) # [1, 1, 2, 3, 5, 8, 13, 21, 34]

# # Внутри функции fib(n), мы сначала задаем базис, если число n равно 1 или 2, это
# # означает, что первое число и второе число последовательности равны 1. Мы так и
# # делаем возвращаем 1. Как мы ранее проговорили: “Последовательно Фибоначчи,
# # это такая последовательность, в которой каждое последующее число равно сумму
# # 2-ух предыдущих”. Так и делаем, складываем на 2 предыдущих числа друг с другом
# # и получаем 3.

# # Быстрая сортировка
# # “Программирование это разбиение чего-то большого и невозможного на что-то
# # маленькое и вполне реальное”

# # Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой
# # должен отгадать. Согласитесь, что мы можем перебирать эти значения в случайном
# # порядке, например: 32, 27, 60, 73… Да, мы можем угадать в какой-то момент, но что
# # если мы обратиться к стратегии “разделяй и властвуй” Обозначим друзей, друг_1
# # это Иван, который загадал число, друг_2 это Петр, который отгадывает. Итак
# # начнем:
# # Иван загадал число 77.
# # Петр: Число больше 50? Иван: Да.
# # Петр: Число больше 75? Иван: Да.
# # Петр: Число больше 87? Иван: Нет.
# # Петр: Число больше 81? Иван: Нет.
# # Петр: Число больше 78? Иван: Нет.
# # Петр: Число больше 76? Иван: Да
# # Число оказалось в диапазоне 76 < x < 78, значит это число 77. Задача решена

# def quicksort(array):
#     if len(array) < 2:
#         return array
#     else:

# pivot = array[0]
# less = [i for i in array[1:] if i <= pivot]
# greater = [i for i in array[1:] if i > pivot]
# return quicksort(less) + [pivot] + quicksort(greater)
# print(quicksort([10, 5, 2, 3]))

# # ● 1-е повторение рекурсии:
#     # ○ array = [10, 5, 2, 3]
#     # ○ pivot = 10
#     # ○ less = [5, 2, 3]
#     # ○ greater = []
#     # ○ return quicksort([5, 2, 3]) + [10] + quicksort([])
# # ● 2-е повторение рекурсии:
#     # ○ array = [5, 2, 3]
#     # ○ pivot = 5
#     # ○ less = [2, 3]
#     # ○ greater = []
#     # ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что
#     # здесь помимо вызова рекурсии добавляется список [10]
# # ● 3-е повторение рекурсии:
#     # ○ array = [2, 3]
#     # ○ return [2, 3] # Сработал базовый случай рекурсии
# # На этом работа рекурсии завершилась и итоговый список будет выглядеть таким
# # образом: [2, 3] + [5] + [10] = [2, 3, 5, 10]

# # Сортировка слиянием

# def merge_sort(nums):
#     if len(nums) > 1:
#         mid = len(nums) // 2
#         left = nums[:mid]
#         right = nums[mid:]
#         merge_sort(left)
#         merge_sort(right)
#         i = j = k = 0
#         while i < len(left) and j < len(right):
#             if left[i] < right[j]:
#                 nums[k] = left[i]
#                 i += 1
#             else:
#                 nums[k] = right[j]
#                 j += 1
#             k += 1

#         while i < len(left):
#             nums[k] = left[i]
#             i += 1
#             k += 1

#         while j < len(right):
#             nums[k] = right[j]
#             j += 1
#             k += 1